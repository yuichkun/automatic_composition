module.exports =
`
(defun stretch (dur pitch &optional note-begin note-end)
  (let '(ret nil) '(pitch-len nil) '(tupletized nil) '(section nil)
    (setf pitch-len (length (flatten pitch)))
    (setf tupletized (gen-repeat pitch-len (/ dur pitch-len)))
    (if (eq note-begin nil)
      (progn
        (setf section (length tupletized))
      )
      (progn
        (if (eq note-end nil)
          (progn
            (setf note-end (length tupletized))
            (setf section (gen-integer note-begin note-end))
          )
          (progn
            (let '(end-point (- (length tupletized) (+ note-end 1)))
              (setf section (gen-integer note-begin end-point))
            )
          )
        )
      )
    )

    (setf ret (flatten (gen-pause (mclist (flatten tupletized)) :section section)))
    (return-from stretch ret)
  )
)

(defun line (size low-note high-note &optional tilt)
  (let '(wave nil)
    (if (eq tilt nil)
      (setf tilt 1.0)
    )
    (setf wave (gen-transition 1 10 size tilt))
    (return-from line (vector-to-pitch (list low-note high-note) wave))
  )
)

(defun rnd-pitch (low-num high-num low-note high-note tonality)
  (let ((result nil) (counter (rnd-range low-num high-num)) (this-pitch nil))
    (dotimes (i counter)
      (setf this-pitch (randomize-octaves (list low-note high-note) (list (rnd-pick (expand-tonality (list low-note tonality))))))
      (push this-pitch result)
    )
    (flatten result)
  )
)

(defun artif-harm (pitchs)
  (let '(ret nil)
    (loop for pitch in pitchs do
      (push (chordize (interval-map pitch '(5))) ret)
    )
    (reverse ret)
  )
)

`;
